# -*- coding: utf-8 -*-
"""Untitled41.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aDGFTD4VAe-MjLFAadAMZNGvTxibgwgC
"""

import requests
from bs4 import BeautifulSoup

# detail_urlsをresultsから生成
detail_urls = [item["detail"] for item in results if "detail" in item]

detail_urls_with_id = [
[idx + 1, url, 0, 0, 0, 0]  # IDとURLを設定し、他は0で初期化
    for idx, url in enumerate(detail_urls)
]

print(detail_urls_with_id)

import os
import requests
from bs4 import BeautifulSoup



#画像格納
for i in range(len(detail_urls_with_id)):
    url = detail_urls_with_id[i][1]

    # HTMLを取得
    response = requests.get(url)
    response.raise_for_status()

    # BeautifulSoupでHTMLを解析
    soup = BeautifulSoup(response.content, "lxml")

    # <div id="image_pager">を探す
    image_pager_div = soup.find("div", id="image_pager")

    # 画像のURLを取得
    if image_pager_div:
        # <img>タグをすべて取得
        img_tags = image_pager_div.find_all("img")

        # 後ろから2番目の画像を取得
        if len(img_tags) >= 2:
            second_last_img_url = "https://www.kaldi.co.jp" + img_tags[-2]["src"]
            detail_urls_with_id[i][2] = second_last_img_url
            print("後ろから2番目の画像URL:", second_last_img_url)
        else:
            print("画像が2つ未満のため、後ろから2番目の画像はありません。")
    else:
        print("id='image_pager'の<div>が見つかりませんでした。")

# ダウンロード先のフォルダを指定
download_folder = "./images"
os.makedirs(download_folder, exist_ok=True)  # フォルダがなければ作成

# detail_urls_with_idのx座標[2]に入っている画像URLをダウンロード
for idx, item in enumerate(detail_urls_with_id, start=1):
    url = item[2]  # x座標[2]の画像URLを取得
    if url:  # URLがある場合のみダウンロード
        response = requests.get(url)
        response.raise_for_status()  # エラーチェック

        # 画像ファイルを保存
        image_path = os.path.join(download_folder, f"image_{idx}.jpg")
        with open(image_path, "wb") as f:
            f.write(response.content)
        print(f"Downloaded: {image_path}")
        detail_urls_with_id[idx-1][2] = image_path
    else:
        print(f"No URL found at index {idx}, skipping download.")

import cv2
import numpy as np
import pathlib
import os
import math
import pandas as pd
from google.colab.patches import cv2_imshow



for j in range(len(detail_urls_with_id)):
  imgCV = cv2.imread(detail_urls_with_id[j][2])


  # 画像が正しく読み込まれているか確認
  if imgCV is None:
      print("画像の読み込みに失敗しました。パスを確認してください。")
  #else:
      # 画像を表示（Colab環境ではcv2_imshowを使う）
      #cv2_imshow(imgCV)

  '''
  # RGB値（例：特定の円の色を指定）
  target_rgb = np.array([200, 80, 110])  # あなたのRGB値に変更

  # RGB値を基に色の範囲を指定（許容範囲を設定）
  lower_bound = target_rgb - 30  # 許容範囲の下限
  upper_bound = target_rgb + 30  # 許容範囲の上限

  # マスク処理のためにBGRに変換（OpenCVはBGRフォーマット）
  lower_bound_bgr = lower_bound[::-1]
  upper_bound_bgr = upper_bound[::-1]

  # 特定の色に該当する部分だけを抽出するためのマスクを作成
  mask = cv2.inRange(imgCV, lower_bound_bgr, upper_bound_bgr)


  # マスク画像を表示（抽出された部分を確認）
  cv2_imshow(mask)
  print()
  '''

  # グレースケールに変換
  gray = cv2.cvtColor(imgCV, cv2.COLOR_BGR2GRAY)

  '''

  # エッジ検出 (Canny)
  edges = cv2.Canny(gray, 50, 150)

  # エッジを表示して確認
  cv2_imshow(edges)
  print()


  # ぼかし処理を追加
  mask_blurred = cv2.GaussianBlur(edges, (5, 5), 2)

  cv2_imshow(mask_blurred)
  print()
  '''

  #円を検出
  circles = cv2.HoughCircles(gray,
                            cv2.HOUGH_GRADIENT,
                            dp=1,
                            minDist=10,
                            param1=50,
                            param2=20,
                            minRadius=5,
                            maxRadius=10)

  if circles is not None:
      # 結果を丸める
      circles = np.uint16(np.around(circles))

      # 検出されたすべての円をループ処理
      for i in circles[0, :]:
          # 円の中心座標 (i[0], i[1]) と半径 i[2] を取得
          center = (i[0], i[1])
          radius = i[2]

          #円の中心座標を表示
          #print(center)


          #テイストバランスの格納
          if i[1] >=320 and i[1] <=340:
            #print(i[0])
            s = i[0] -140
            #print(s)
            t = math.floor(s/21*5)
            #print(t)
            k = math.floor(t/5)*5
            #print(k)
            detail_urls_with_id[j][3] = k


          #ボディの格納
          if i[1] >=415 and i[1] <=435:
            if i[0] <= 200:
              detail_urls_with_id[j][4] = 0
            elif  200 < i[0] and i[0] <= 300:
              detail_urls_with_id[j][4] = 25
            elif  300 < i[0] and i[0] <= 400:
              detail_urls_with_id[j][4] = 50
            elif  400 < i[0] and i[0] <= 500:
              detail_urls_with_id[j][4] = 75
            elif  500 < i[0] :
              detail_urls_with_id[j][4] = 100




          #ローストの格納
          if i[1] >=505 and i[1] <=525:
            #print(i[0])

            s = i[0] -135
            #print(s)
            t = math.floor(s/30)*7
            #print(t)

            detail_urls_with_id[j][5] = t
          cv2.circle(imgCV, center, radius, (255, 0, 0), -1)

  else:
      print("円が検出されませんでした。")

#print(data)


# リストを逆順でループし、条件を満たす要素を削除
for j in range(len(detail_urls_with_id) - 1, -1, -1):
    if (detail_urls_with_id[j][3] == 0 and detail_urls_with_id[j][4] == 0 and detail_urls_with_id[j][5] == 0) or \
       (detail_urls_with_id[j][3] < 0 or detail_urls_with_id[j][3] > 100 or
        detail_urls_with_id[j][4] < 0 or detail_urls_with_id[j][4] > 100 or
        detail_urls_with_id[j][5] < 0 or detail_urls_with_id[j][5] > 100):
        del detail_urls_with_id[j]  # 条件を満たす要素を削除




# detail_urls_with_idを2次元のリストとしてDataFrameに変換
df = pd.DataFrame(detail_urls_with_id)

# CSVファイルに余分な行やヘッダーを含めずに保存
df.to_csv("score.csv", index=False, header=False)

# 保存した内容を再読み込みして表示（確認用）
df = pd.read_csv("score.csv", header=None)
print(df)
